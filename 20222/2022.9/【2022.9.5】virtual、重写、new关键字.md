# 复习 
    值类型不能是协变/逆变

# 虚方法、虚拟属性（virtual property）
    1、You cannot use the virtual modifier with the【static, abstract, private, or override】 modifiers. 
    2、子类重写虚方法/虚拟属性时 不能改变 访问修饰符
    3、子类重写方法可通过base.来调用父类的成员
    4、同名方法调用优先级问题
        public class Derived : Base
        {
            public override void DoWork(int param) { }
            public void DoWork(double param) { }
        }

        int val = 5;
        Derived d = new Derived();
        d.DoWork(val);  // Calls DoWork(double).
        上述结果调用的是DoWork(double).因为int可以隐式转换为double。而重写方法不被编译器视为一个类的“原始方法”,所以优先级靠后不被调用。
        解决方法：改名 或者：
        ((Base)d).DoWork(val);  // Calls DoWork(int) on Derived.

# new关键字
https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/new-modifier
    1、与override的异同：https://www.cnblogs.com/vsSure/p/7816639.html
        相同：都是重写父类的方法，各自子类对象调用方法时会调用子类的实现，屏蔽父类
        不同：当子类对象隐式转换为父类时，此时调用方法，override重写的子类方法继续屏蔽父类被调用，而new声明的方法将不被调用，而是直接调用父类方法
        例子：
             public class Animal
             {
                 public virtual void Say()
                 {
                     Console.WriteLine("Hello,Animal");
                 }
             }
             public class Dog : Animal
             {
                 public override void Say()
                 {
                     Console.WriteLine("Hello,Dog");
                 }
             }
             public class Cat : Animal
             {
                public new void Say()
                 {
                     Console.WriteLine("Hello,Cat");
                 }
             }
            Cat c = new Cat();
            Animal a = c as Animal;//子类转换为父类。注意此时a与c指向同一对象，但c是作为Cat类访问，而a是作为Animal类访问
            c.Say();//此时调用的是new的方法
            a.Say();//此时调用的是父类中的方法
            输出：
            Hello,Cat
            Hello,Animal

# 接口
